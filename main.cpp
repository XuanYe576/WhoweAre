#include "raylib.h"
#include "raymath.h"
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <cctype>
#include <string>
#include <vector>
 struct Player { Vector3 position; float yaw; float pitch; }; struct Note { Vector3 position; std::string text; }; static Vector3 GetForward(const Player &p) { float cp = cosf(p.pitch); Vector3 f{cp * sinf(p.yaw), sinf(p.pitch), cp * cosf(p.yaw)}; return Vector3Normalize(f); } static std::string EscapeJson(const std::string &text) { std::string out; out.reserve(text.size()); for (char c : text) { switch (c) { case '\\': out += "\\\\"; break; case '"': out += "\\\""; break; case '\n': out += "\\n"; break; default: out += c; break; } } return out; } static void SaveNotes(const std::vector<Note> &notes, const std::string &path) { std::ofstream file(path, std::ios::trunc); file << "[\n"; for (size_t i = 0; i < notes.size(); ++i) { const Note &n = notes[i]; file << " {\"x\":" << n.position.x << ",\"y\":" << n.position.y << ",\"z\":" << n.position.z << ",\"text\":\"" << EscapeJson(n.text) << "\"}"; if (i + 1 < notes.size()) file << ","; file << "\n"; } file << "]\n"; }
static std::string ParseJsonString(const std::string &s, size_t &i) {
    std::string out;
    if (i >= s.size() || s[i] != '"') return out;
    ++i;
    while (i < s.size()) {
        char c = s[i++];
        if (c == '"') break;
        if (c == '\\' && i < s.size()) {
            char esc = s[i++];
            switch (esc) {
                case 'n': out.push_back('\n'); break;
                case '\\': out.push_back('\\'); break;
                case '"': out.push_back('"'); break;
                default: out.push_back(esc); break;
            }
        } else {
            out.push_back(c);
        }
    }
    return out;
}
static float ParseJsonNumber(const std::string &s, size_t &i) {
    const char *startPtr = s.c_str() + i;
    char *endPtr = nullptr;
    float v = strtof(startPtr, &endPtr);
    i = (size_t)(endPtr - s.c_str());
    return v;
}
static void SkipWs(const std::string &s, size_t &i) { while (i < s.size() && std::isspace((unsigned char)s[i])) ++i; }
static void LoadNotes(const std::string &path, std::vector<Note> &notes, float wallX, float wallHeight, float hubDepth) {
    std::ifstream file(path);
    if (!file.is_open()) return;
    std::string json((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    size_t i = 0;
    SkipWs(json, i);
    if (i >= json.size() || json[i] != '[') return;
    ++i;
    while (i < json.size()) {
        SkipWs(json, i);
        if (i < json.size() && json[i] == ']') break;
        if (json[i] == ',') { ++i; continue; }
        if (json[i] != '{') { ++i; continue; }
        ++i;
        Note n{};
        while (i < json.size()) {
            SkipWs(json, i);
            if (i < json.size() && json[i] == '}') { ++i; break; }
            if (json[i] == ',') { ++i; continue; }
            if (json[i] != '"') { ++i; continue; }
            std::string key = ParseJsonString(json, i);
            SkipWs(json, i);
            if (i < json.size() && json[i] == ':') ++i;
            SkipWs(json, i);
            if (key == "x") n.position.x = ParseJsonNumber(json, i);
            else if (key == "y") n.position.y = ParseJsonNumber(json, i);
            else if (key == "z") n.position.z = ParseJsonNumber(json, i);
            else if (key == "text") n.text = ParseJsonString(json, i);
            else { while (i < json.size() && json[i] != ',' && json[i] != '}') ++i; }
        }
        if (n.text.empty()) continue;
        n.position.x = (n.position.x >= 0.0f) ? wallX : -wallX;
        n.position.y = Clamp(n.position.y, 0.6f, wallHeight - 0.6f);
        n.position.z = Clamp(n.position.z, 0.5f, hubDepth - 0.5f);
        notes.push_back(n);
    }
}
 static Color Shade(Color base, Vector3 point, Vector3 light) { float dist = Vector3Distance(point, light); float factor = Clamp(1.0f / (1.0f + 0.35f * dist * dist), 0.25f, 1.0f); Color c{}; c.r = (unsigned char)Clamp(base.r * (0.35f + 0.65f * factor) + 20.0f * factor, 0.0f, 255.0f); c.g = (unsigned char)Clamp(base.g * (0.35f + 0.65f * factor) + 20.0f * factor, 0.0f, 255.0f); c.b = (unsigned char)Clamp(base.b * (0.35f + 0.65f * factor) + 20.0f * factor, 0.0f, 255.0f); c.a = base.a; return c; } static bool RaycastToWalls(const Player &p, float wallX, float hubDepth, float wallHeight, Vector3 *hitOut) { Vector3 origin = p.position; Vector3 dir = GetForward(p); float bestT = 1e9f; bool hit = false; auto testWall = [&](float targetX) { if (fabsf(dir.x) < 0.0001f) return; float t = (targetX - origin.x) / dir.x; if (t <= 0.0f) return; Vector3 pHit = Vector3Add(origin, Vector3Scale(dir, t)); if (pHit.z < 0.0f || pHit.z > hubDepth) return; if (pHit.y < 0.1f || pHit.y > wallHeight - 0.1f) return; if (t < bestT) { bestT = t; *hitOut = pHit; hit = true; } }; testWall(wallX); testWall(-wallX); return hit; } int main() { SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_MSAA_4X_HINT); InitWindow(1280, 720, "Grid hallway note prototype"); ToggleFullscreen(); DisableCursor(); SetTargetFPS(60); std::srand((unsigned)std::time(nullptr)); const float mouseSensX = 0.0035f; const float mouseSensY = 0.0030f; RenderTexture2D target = LoadRenderTexture(GetScreenWidth(), GetScreenHeight()); Player player{{0.0f, 1.6f, -3.5f}, 0.0f, 0.0f}; Camera3D camera{}; camera.position = player.position; camera.target = Vector3Add(player.position, GetForward(player)); camera.up = {0.0f, 1.0f, 0.0f}; camera.fovy = 75.0f; camera.projection = CAMERA_PERSPECTIVE; std::vector<Note> notes; bool typing = false; std::string noteBuffer; const float wallHeight = 16.0f; const float hubDepth = 32.0f; const float basePlatformWidth = 9.0f; bool exploredOutside = false; bool choiceUnlocked = false; bool showOverwhelm = false; float overwhelmTimer = 0.0f; bool exitPopup = false; float exitTimer = 0.0f; const Vector3 tablePos = {0.0f, 0.5f, hubDepth - 1.0f}; bool showWarning = true; bool warningDismissed = false; float warningAlpha = 1.0f; int lastNoteIndex = -1; LoadNotes("notes.json", notes, basePlatformWidth * 0.5f, wallHeight, hubDepth); const char *msgs[] = {"hello", "hi", "is anyone here", "still there?", "echo..."}; if (notes.empty()) { for (int i = 0; i < 5; ++i) { Note n; bool left = (std::rand() % 2) == 0; n.position.x = left ? -basePlatformWidth * 0.5f : basePlatformWidth * 0.5f; float dz = (float)(std::rand() % 1000) / 1000.0f; n.position.z = 1.0f + dz * (hubDepth - 2.0f); float dy = (float)(std::rand() % 1000) / 1000.0f; n.position.y = 0.6f + dy * (wallHeight - 1.2f); n.text = msgs[i % 5]; notes.push_back(n); } }
while (true) { if (WindowShouldClose()) exitPopup = true;  float dt = GetFrameTime(); if (showWarning) { if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON) || IsKeyPressed(KEY_ENTER) || IsKeyPressed(KEY_SPACE)) warningDismissed = true; if (warningDismissed) { warningAlpha -= dt * 1.2f; if (warningAlpha < 0.0f) { warningAlpha = 0.0f; showWarning = false; } } } if (showOverwhelm) { overwhelmTimer += dt; if (overwhelmTimer > 3.0f) break; } if (exitPopup) { exitTimer += dt; if (exitTimer > 2.0f) break; } float aspect = (float)GetScreenWidth() / (float)GetScreenHeight(); bool compact = aspect < 1.4f; float platformWidth = basePlatformWidth; float spanX = compact ? 12.0f : 20.0f; float spanZ = 80.0f; Vector3 lightPos = {player.position.x, wallHeight - 0.4f, player.position.z + 2.5f}; float distFromOrigin = std::sqrt(player.position.x * player.position.x + player.position.z * player.position.z); exploredOutside = exploredOutside || distFromOrigin > hubDepth + 10.0f; choiceUnlocked = exploredOutside; bool nearHub = fabsf(player.position.z) < hubDepth && fabsf(player.position.x) < spanX * 0.5f && distFromOrigin < hubDepth * 1.5f; float blackoutAlpha = Clamp((distFromOrigin - (hubDepth + 5.0f)) / 20.0f, 0.0f, 1.0f); if (!nearHub && distFromOrigin > hubDepth + 5.0f) exitPopup = true; if (!typing) { Vector2 md = GetMouseDelta(); player.yaw -= md.x * mouseSensX; player.pitch -= md.y * mouseSensY; player.pitch = Clamp(player.pitch, -PI / 2 + 0.01f, PI / 2 - 0.01f); Vector3 forward = GetForward(player); Vector3 right = Vector3Normalize(Vector3CrossProduct(forward, {0.0f, 1.0f, 0.0f})); Vector3 move = {0.0f, 0.0f, 0.0f}; if (IsKeyDown(KEY_W)) move = Vector3Add(move, forward); if (IsKeyDown(KEY_S)) move = Vector3Subtract(move, forward); if (IsKeyDown(KEY_A)) move = Vector3Subtract(move, right); if (IsKeyDown(KEY_D)) move = Vector3Add(move, right); if (IsKeyDown(KEY_SPACE)) move.y += 1.0f; if (IsKeyDown(KEY_LEFT_SHIFT)) move.y -= 1.0f; if (Vector3Length(move) > 0.001f) { move = Vector3Scale(Vector3Normalize(move), dt * 4.0f); Vector3 candidate = Vector3Add(player.position, move); if (candidate.z >= 0.0f && candidate.z <= hubDepth + 0.2f) { float xLimit = basePlatformWidth * 0.5f - 0.25f; candidate.x = Clamp(candidate.x, -xLimit, xLimit); candidate.z = Clamp(candidate.z, -5.0f, hubDepth - 0.3f); } player.position = candidate; } player.position.y = Clamp(player.position.y, 0.5f, wallHeight - 0.5f); if (IsKeyPressed(KEY_SLASH)) { typing = true; noteBuffer.clear(); EnableCursor(); SetMouseCursor(MOUSE_CURSOR_IBEAM); } } else { int key = GetCharPressed(); while (key > 0) { if (key >= 32 && key <= 125) noteBuffer.push_back((char)key); key = GetCharPressed(); } if (IsKeyPressed(KEY_BACKSPACE) && !noteBuffer.empty()) noteBuffer.pop_back(); if (IsKeyPressed(KEY_ESCAPE)) { typing = false; noteBuffer.clear(); DisableCursor(); SetMouseCursor(MOUSE_CURSOR_CROSSHAIR); } if (IsKeyPressed(KEY_ENTER) && !noteBuffer.empty()) { Vector3 wallHit; if (nearHub && RaycastToWalls(player, platformWidth * 0.5f, hubDepth, wallHeight, &wallHit)) { Note n; n.position = wallHit; n.text = noteBuffer; notes.push_back(n); lastNoteIndex = (int)notes.size() - 1; SaveNotes(notes, "notes.json"); typing = false; noteBuffer.clear(); DisableCursor(); SetMouseCursor(MOUSE_CURSOR_CROSSHAIR); } } } camera.position = player.position; camera.target = Vector3Add(player.position, GetForward(player)); if (target.texture.width != GetScreenWidth() || target.texture.height != GetScreenHeight()) { UnloadRenderTexture(target); target = LoadRenderTexture(GetScreenWidth(), GetScreenHeight()); } BeginTextureMode(target); ClearBackground(ColorFromNormalized((Vector4){0.05f, 0.05f, 0.07f, 1.0f})); BeginMode3D(camera); Vector3 groundPos = {player.position.x, 0.0f, player.position.z}; Vector2 groundSize = {spanX * 2.2f, spanZ}; DrawPlane(groundPos, groundSize, Shade(BLACK, groundPos, lightPos)); float tile = 5.0f; float startX = floorf((player.position.x - spanX) / tile) * tile; float endX = player.position.x + spanX; float startZ = floorf((player.position.z - spanZ * 0.5f) / tile) * tile; float endZ = player.position.z + spanZ * 0.5f; for (float x = startX; x < endX; x += tile) { for (float z = startZ; z < endZ; z += tile) { Vector3 cellCenter = {x + tile * 0.5f, 0.01f, z + tile * 0.5f}; Vector3 cellSize = {tile - 0.1f, 0.02f, tile - 0.1f}; DrawCubeV(cellCenter, cellSize, Shade(DARKGRAY, cellCenter, lightPos)); } } if (nearHub) { float step = hubDepth / 4.0f; for (float z = step; z <= hubDepth - step; z += step) { Vector3 bLight = {0.0f, wallHeight - 0.2f, z}; DrawSphereEx(bLight, 0.12f, 6, 6, (Color){100, 140, 255, 255}); } Vector3 wallSize = {0.25f, wallHeight, hubDepth}; Vector3 leftWallPos = {-platformWidth * 0.5f, wallHeight * 0.5f, hubDepth * 0.5f}; Vector3 rightWallPos = {platformWidth * 0.5f, wallHeight * 0.5f, hubDepth * 0.5f}; DrawCubeV(leftWallPos, wallSize, Shade((Color){30, 30, 40, 255}, leftWallPos, lightPos)); DrawCubeV(rightWallPos, wallSize, Shade((Color){30, 30, 40, 255}, rightWallPos, lightPos)); Vector3 roofSize = {platformWidth, 0.25f, hubDepth}; Vector3 roofPos = {0.0f, wallHeight, hubDepth * 0.5f}; DrawCubeV(roofPos, roofSize, Shade((Color){20, 20, 28, 255}, roofPos, lightPos)); Vector3 backWallSize = {platformWidth, wallHeight, 0.25f}; Vector3 backWallPos = {0.0f, wallHeight * 0.5f, hubDepth}; DrawCubeV(backWallPos, backWallSize, Shade((Color){22, 22, 30, 255}, backWallPos, lightPos)); float lineThickness = 0.03f; for (float y = 0.0f; y <= wallHeight; y += 1.0f) { Vector3 ls = {leftWallPos.x, y, hubDepth * 0.5f}; Vector3 lss = {wallSize.x + 0.001f, lineThickness, hubDepth}; DrawCubeV(ls, lss, Shade(DARKGRAY, ls, lightPos)); Vector3 rs = {rightWallPos.x, y, hubDepth * 0.5f}; Vector3 rss = {wallSize.x + 0.001f, lineThickness, hubDepth}; DrawCubeV(rs, rss, Shade(DARKGRAY, rs, lightPos)); } for (float z = 0.0f; z <= hubDepth; z += 1.0f) { Vector3 ls = {leftWallPos.x, wallHeight * 0.5f, z}; Vector3 lss = {wallSize.x + 0.001f, wallHeight, lineThickness}; DrawCubeV(ls, lss, Shade(DARKGRAY, ls, lightPos)); Vector3 rs = {rightWallPos.x, wallHeight * 0.5f, z}; Vector3 rss = {wallSize.x + 0.001f, wallHeight, lineThickness}; DrawCubeV(rs, rss, Shade(DARKGRAY, rs, lightPos)); } for (float x = -platformWidth * 0.5f; x <= platformWidth * 0.5f; x += 1.0f) { Vector3 rz = {x, roofPos.y, hubDepth * 0.5f}; Vector3 rzs = {lineThickness, lineThickness, hubDepth}; DrawCubeV(rz, rzs, Shade(DARKGRAY, rz, lightPos)); } for (float z = 0.0f; z <= hubDepth; z += 1.0f) { Vector3 rx = {0.0f, roofPos.y, z}; Vector3 rxs = {platformWidth, lineThickness, lineThickness}; DrawCubeV(rx, rxs, Shade(DARKGRAY, rx, lightPos)); } for (float y = 0.0f; y <= wallHeight; y += 1.0f) { Vector3 backH = {0.0f, y, hubDepth}; Vector3 backHs = {platformWidth, lineThickness, lineThickness}; DrawCubeV(backH, backHs, Shade(DARKGRAY, backH, lightPos)); } for (float x = -platformWidth * 0.5f; x <= platformWidth * 0.5f; x += 1.0f) { Vector3 backV = {x, wallHeight * 0.5f, hubDepth}; Vector3 backVs = {lineThickness, wallHeight, lineThickness}; DrawCubeV(backV, backVs, Shade(DARKGRAY, backV, lightPos)); } } for (size_t i = 0; i < notes.size(); ++i) { const Note &n = notes[i]; Vector3 noteSize = {0.35f, 0.35f, 0.02f}; Color stickyColor = (i == (size_t)lastNoteIndex) ? (Color){255, 80, 80, 255} : (Color){255, 247, 114, 255}; DrawCubeV(n.position, noteSize, Shade(stickyColor, n.position, lightPos)); DrawCubeWiresV(n.position, noteSize, Fade(BLACK, 0.6f)); if (i == (size_t)lastNoteIndex) { Vector3 bubblePos = Vector3Add(n.position, (Vector3){0.0f, noteSize.y * 0.6f, 0.0f}); DrawSphereEx(bubblePos, 0.08f, 6, 6, RED); } } EndMode3D(); for (size_t i = 0; i < notes.size(); ++i) { const Note &n = notes[i]; Vector2 pos2d = GetWorldToScreen(n.position, camera); if (pos2d.x > 0 && pos2d.x < GetScreenWidth() && pos2d.y > 0 && pos2d.y < GetScreenHeight()) { int w = 180; int h = 50; Color cardColor = (i == (size_t)lastNoteIndex) ? (Color){255, 100, 100, 220} : (Color){255, 247, 114, 255}; DrawRectangle(pos2d.x - w / 2, pos2d.y - h / 2, w, h, Fade(cardColor, 0.85f)); DrawRectangleLines(pos2d.x - w / 2, pos2d.y - h / 2, w, h, Fade(BLACK, 0.6f)); DrawText(TextSubtext(n.text.c_str(), 0, 64), pos2d.x - w / 2 + 6, pos2d.y - h / 2 + 8, 16, BLACK); } } if (nearHub) { Vector3 labelPos = {-basePlatformWidth * 0.5f - 0.05f, wallHeight - 0.6f, hubDepth * 0.2f}; DrawSphereEx(labelPos, 0.25f, 10, 10, RED); Vector2 label2d = GetWorldToScreen(Vector3Add(labelPos, (Vector3){0.0f, 0.35f, 0.0f}), camera); if (label2d.x > 0 && label2d.x < GetScreenWidth() && label2d.y > 0 && label2d.y < GetScreenHeight()) { char buf[64]; snprintf(buf, sizeof(buf), "%zu", notes.size()); DrawText(buf, label2d.x - 12, label2d.y - 10, 18, RED); } } if (nearHub) { DrawCubeV(tablePos, (Vector3){1.8f, 0.5f, 1.2f}, Shade((Color){60, 60, 70, 255}, tablePos, lightPos)); Vector3 platePos = {tablePos.x, tablePos.y + 0.3f, tablePos.z}; DrawCubeV(platePos, (Vector3){1.9f, 0.05f, 1.2f}, Shade((Color){90, 90, 100, 255}, platePos, lightPos)); Vector2 screen = GetWorldToScreen(Vector3Add(tablePos, (Vector3){0.0f, 0.8f, 0.0f}), camera); if (screen.x > 0 && screen.x < GetScreenWidth() && screen.y > 0 && screen.y < GetScreenHeight()) { float distToTable = Vector3Length(Vector3Subtract(player.position, tablePos)); float alpha = Clamp(1.0f - (distToTable - 3.0f) / 12.0f, 0.2f, 1.0f); int font = 12; DrawText("Who are you?", screen.x - 70, screen.y - 26, font, Fade(RAYWHITE, alpha)); DrawText("1) social", screen.x - 70, screen.y - 10, font, Fade(RAYWHITE, alpha)); Color selfColor = (alpha > 0.95f || !nearHub) ? RAYWHITE : Fade(GRAY, alpha); DrawText("2) yourself", screen.x - 70, screen.y + 6, font, Fade(selfColor, alpha)); if (distToTable < 3.5f && alpha > 0.95f) { if (IsKeyPressed('1')) { showOverwhelm = true; overwhelmTimer = 0.0f; } if (IsKeyPressed('2')) { exitPopup = true; exitTimer = 0.0f; showOverwhelm = false; } } } } DrawCircleV({(float)GetScreenWidth() / 2.0f, (float)GetScreenHeight() / 2.0f}, 3.0f, RED); DrawText("WASD/mouse, Space/Shift", 14, 12, 16, RAYWHITE); DrawText("/ note Enter pin Esc cancel", 14, 32, 16, GRAY); if (typing) { int boxH = 50; DrawRectangle(10, GetScreenHeight() - boxH - 10, GetScreenWidth() - 20, boxH, Fade(BLACK, 0.65f)); DrawRectangleLines(10, GetScreenHeight() - boxH - 10, GetScreenWidth() - 20, boxH, RAYWHITE); DrawText(noteBuffer.c_str(), 20, GetScreenHeight() - boxH, 22, RAYWHITE); } if (showOverwhelm) { DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(BLACK, 0.8f)); if (notes.empty()) { DrawText("No notes yet.", 20, 40, 24, RAYWHITE); } else { for (int i = 0; i < 120; ++i) { const std::string &t = notes[i % notes.size()].text; int x = std::rand() % GetScreenWidth(); int y = std::rand() % GetScreenHeight(); DrawText(t.c_str(), x, y, 20, RAYWHITE); } } char buf[64]; snprintf(buf, sizeof(buf), "Overwhelmed... closing soon"); int tw = MeasureText(buf, 20); DrawText(buf, (GetScreenWidth() - tw) / 2, GetScreenHeight() - 40, 20, RED); } else if (exitPopup) { DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(BLACK, 0.6f)); const char *msg = "Determined by yourself."; int tw = MeasureText(msg, 26); DrawRectangle((GetScreenWidth() - tw - 60) / 2, (GetScreenHeight() - 70) / 2, tw + 60, 70, Fade(GRAY, 0.4f)); DrawRectangleLines((GetScreenWidth() - tw - 60) / 2, (GetScreenHeight() - 70) / 2, tw + 60, 70, RAYWHITE); DrawText(msg, (GetScreenWidth() - tw) / 2, GetScreenHeight() / 2 - 12, 26, RAYWHITE); } if (showWarning) { DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(BLACK, 0.9f * warningAlpha)); const char *w1 = "WARNING: PHOTOSENSITIVITY/EPILEPSY/SEIZURES"; const char *w2 = "Some individuals may experience seizures or blackouts from flashing lights/patterns. Stop if symptoms occur."; const char *w3 = "Consult a physician if you have a history of seizures. Parents monitor children."; int y0 = GetScreenHeight() / 2 - 30; DrawText(w1, (GetScreenWidth() - MeasureText(w1, 18)) / 2, y0, 18, RED); DrawText(w2, (GetScreenWidth() - MeasureText(w2, 16)) / 2, y0 + 24, 16, RAYWHITE); DrawText(w3, (GetScreenWidth() - MeasureText(w3, 16)) / 2, y0 + 44, 16, RAYWHITE); } else if (blackoutAlpha > 0.01f) { DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(BLACK, blackoutAlpha)); } EndTextureMode(); BeginDrawing(); ClearBackground(BLACK); Rectangle src = {0.0f, 0.0f, (float)target.texture.width, -(float)target.texture.height};Rectangle dst = {0.0f, 0.0f, (float)GetScreenWidth(), (float)GetScreenHeight()};DrawTexturePro(target.texture, src, dst, {0.0f, 0.0f}, 0.0f, RAYWHITE);EndDrawing();}CloseWindow();return 0;}
